import qualified Data.Map as Map
import Type
import Core
import Analyzer
import Parser
import System.IO
import Asm
import Java

globalEnv = coreEnv

eval :: Exp -> Env -> (Exp, Env)
eval exp = analyze exp

repl :: Env -> IO ()
repl env = do
  putStr "> "
  hFlush stdout
  line <- getLine
  case line of
    ":quit" -> do putStrLn "Bye See you soon!"
                  return ()
    ":compile" -> java $ do cw <- newClassWriter 0
                            cw <.> visit 49 (1 + 32) "Hello" Nothing "java/lang/Object" Nothing
                            cw <.> visitSource "Hello.java" Nothing
                            byteCode <- cw <.> toByteArray
                            io $ putStrLn "Generated Bytecode"
                            cw <.> visitEnd
    _ -> do let (result, newEnv) = foldl (\(_, env) exp -> eval exp env) (Unit, env) (parse line)
            putStrLn $ show result
            hFlush stdout
            repl newEnv
  
main :: IO()
main = do
  putStrLn "Kand REPL"
  putStrLn "To exit type :quit"
  repl globalEnv

